<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DSAS: String</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DSAS
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 制作者 Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'搜索');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','搜索');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">类</a> &#124;
<a href="#func-members">函数</a>  </div>
  <div class="headertitle">
<div class="title">String<div class="ingroups"><a class="el" href="group___linear.html">Linear Struct</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
类</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdsa_1_1_string.html">dsa::String</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">字符串类  <a href="classdsa_1_1_string.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
函数</h2></td></tr>
<tr class="memitem:gae20271e600a2cc9681f78fd4743b8acc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___l_string.html#gae20271e600a2cc9681f78fd4743b8acc">dsa::strlen</a> (const char *str)</td></tr>
<tr class="memdesc:gae20271e600a2cc9681f78fd4743b8acc"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取字符串长度  <a href="group___l_string.html#gae20271e600a2cc9681f78fd4743b8acc">更多...</a><br /></td></tr>
<tr class="separator:gae20271e600a2cc9681f78fd4743b8acc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7009fa633463e4403e3cad0478c6910a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___l_string.html#ga7009fa633463e4403e3cad0478c6910a">dsa::match_bf1</a> (char *P, char *T)</td></tr>
<tr class="memdesc:ga7009fa633463e4403e3cad0478c6910a"><td class="mdescLeft">&#160;</td><td class="mdescRight">蛮力匹配(Brute-force-1)  <a href="group___l_string.html#ga7009fa633463e4403e3cad0478c6910a">更多...</a><br /></td></tr>
<tr class="separator:ga7009fa633463e4403e3cad0478c6910a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga582dcdb5f9becbf92816d2461abaef4e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___l_string.html#ga582dcdb5f9becbf92816d2461abaef4e">dsa::match_bf2</a> (char *P, char *T)</td></tr>
<tr class="memdesc:ga582dcdb5f9becbf92816d2461abaef4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">蛮力匹配(Brute-force-2)  <a href="group___l_string.html#ga582dcdb5f9becbf92816d2461abaef4e">更多...</a><br /></td></tr>
<tr class="separator:ga582dcdb5f9becbf92816d2461abaef4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3e734ffbeda146022f684dad29d29c7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___l_string.html#gaf3e734ffbeda146022f684dad29d29c7">dsa::match_kmp</a> (char *P, char *T)</td></tr>
<tr class="memdesc:gaf3e734ffbeda146022f684dad29d29c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">KMP匹配算法  <a href="group___l_string.html#gaf3e734ffbeda146022f684dad29d29c7">更多...</a><br /></td></tr>
<tr class="separator:gaf3e734ffbeda146022f684dad29d29c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6172d6a559c55ac355e43342164e8a06"><td class="memItemLeft" align="right" valign="top">int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___l_string.html#ga6172d6a559c55ac355e43342164e8a06">dsa::build_next</a> (char *P)</td></tr>
<tr class="memdesc:ga6172d6a559c55ac355e43342164e8a06"><td class="mdescLeft">&#160;</td><td class="mdescRight">建立next表  <a href="group___l_string.html#ga6172d6a559c55ac355e43342164e8a06">更多...</a><br /></td></tr>
<tr class="separator:ga6172d6a559c55ac355e43342164e8a06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaec7b26a216963749bba23d7f58b82e6"><td class="memItemLeft" align="right" valign="top">int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___l_string.html#gaaec7b26a216963749bba23d7f58b82e6">dsa::build_next_improved</a> (char *P)</td></tr>
<tr class="memdesc:gaaec7b26a216963749bba23d7f58b82e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">建立next表改进版  <a href="group___l_string.html#gaaec7b26a216963749bba23d7f58b82e6">更多...</a><br /></td></tr>
<tr class="separator:gaaec7b26a216963749bba23d7f58b82e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6fa260ff01c5f9166d69b5fc81a5ab5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___l_string.html#gaf6fa260ff01c5f9166d69b5fc81a5ab5">dsa::match_bm_bc</a> (char *P, char *T)</td></tr>
<tr class="memdesc:gaf6fa260ff01c5f9166d69b5fc81a5ab5"><td class="mdescLeft">&#160;</td><td class="mdescRight">BM匹配算法  <a href="group___l_string.html#gaf6fa260ff01c5f9166d69b5fc81a5ab5">更多...</a><br /></td></tr>
<tr class="separator:gaf6fa260ff01c5f9166d69b5fc81a5ab5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac169036d3ff06d936ae8e6c4fe2f98eb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___l_string.html#gac169036d3ff06d936ae8e6c4fe2f98eb">dsa::match_bm_bcgs</a> (char *P, char *T)</td></tr>
<tr class="memdesc:gac169036d3ff06d936ae8e6c4fe2f98eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">BM+GS匹配算法  <a href="group___l_string.html#gac169036d3ff06d936ae8e6c4fe2f98eb">更多...</a><br /></td></tr>
<tr class="separator:gac169036d3ff06d936ae8e6c4fe2f98eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b9f8168f2c4d98d7f046429a4695ca2"><td class="memItemLeft" align="right" valign="top">int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___l_string.html#ga0b9f8168f2c4d98d7f046429a4695ca2">dsa::build_bc</a> (char *P)</td></tr>
<tr class="memdesc:ga0b9f8168f2c4d98d7f046429a4695ca2"><td class="mdescLeft">&#160;</td><td class="mdescRight">建立bc表(bad-character)  <a href="group___l_string.html#ga0b9f8168f2c4d98d7f046429a4695ca2">更多...</a><br /></td></tr>
<tr class="separator:ga0b9f8168f2c4d98d7f046429a4695ca2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50084b5c38e0a5e1edaf0ee7ce1df6b1"><td class="memItemLeft" align="right" valign="top">int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___l_string.html#ga50084b5c38e0a5e1edaf0ee7ce1df6b1">dsa::build_gs</a> (char *P)</td></tr>
<tr class="memdesc:ga50084b5c38e0a5e1edaf0ee7ce1df6b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">建立gs表(good suffix)  <a href="group___l_string.html#ga50084b5c38e0a5e1edaf0ee7ce1df6b1">更多...</a><br /></td></tr>
<tr class="separator:ga50084b5c38e0a5e1edaf0ee7ce1df6b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">详细描述</h2>
<p>串结构 </p>
<h2 class="groupheader">函数说明</h2>
<a id="ga0b9f8168f2c4d98d7f046429a4695ca2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0b9f8168f2c4d98d7f046429a4695ca2">&#9670;&nbsp;</a></span>build_bc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int * dsa::build_bc </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>P</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>建立bc表(bad-character) </p>
<pre>
              i           i+j
Text: ------ [           ] X [*****]----------
             |           |
             |           | j: 失配点
Pattern:     [           ] Y [*****]
             |           |
             |     [     ] X [           ]
                           t = bc['X']
             P在P[j]处失配，若要在T[i+j]处成功匹配，则P中应该也有一个字符X；
             故可以直接右移 j-bc['X'] 重新进行比较（bc['X']表示字符X在P中的下标）。
特殊情况1：P中有多个字符X时，取下标最大的字符X（即P中在t后面的子串，不能再有字符X）
特殊情况2：P中没有字符X时，取bc['X']=-1（类似的，-1为假想的通配符位置，同时，P中在t后面的子串中，必定没有字符X）
特殊情况3：bc['X'] &gt; j 时（即X在Y的后面），则只需向右移1个字符，不需要向左移；
           因为在 i 前面的位置，都已经排除了，不可能发生成功的匹配；
           且若有多个字符X时，在j前面也可能有X（但下标不是最大的），故只能向右移一个字符。
总结：
     情况1,2：右移j-bc['X']， 则i = i+j-bc['X']，情况2即为i = i+j+1
     情况3：  右移1</pre><pre></pre><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">P</td><td>Pattern，模式字符，即待匹配的字符 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd></dd></dl>
<dl class="retval"><dt>返回值</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga50084b5c38e0a5e1edaf0ee7ce1df6b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga50084b5c38e0a5e1edaf0ee7ce1df6b1">&#9670;&nbsp;</a></span>build_gs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int * dsa::build_gs </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>P</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>建立gs表(good suffix) </p>
<pre></pre><pre>在不确定P中失配点j左侧有没有字符X时，才用gs表（即bc表的情况三）
              i           i+j
Text: ------ [           ] X [abcde]----------
             |           |
             |           | j: 失配点
Pattern:     [           ] Y [abcde]
             |           |     \
             |           |      good suffix为P的子串(若有多个good suffix，取使gs[j]最小的，即k最大的)
             |           | k   /
Pattern:     |     [     ] # [abcde      ]
                          gs[j] = j-k &amp;&amp; P[gs[j]]！= 'Y'</pre><pre>                                  h (good suffix为P的前缀)
Pattern:                       [cde                  ]
                                  gs[j] = len(P) - h
P在P[j]处失配，则i直接向右移gs[j]距离。</pre><pre>(1) gs为子串和前缀时的区别：
Text:    -----------------X--------------
                      |&lt;-- r1 --&gt;|    =&gt; 子串与后缀匹配
                i     |   j      |
Pattern: [abc   #   abc X * X  abc]
            |           k        |
            |&lt;------- r2 -------&gt;|    =&gt; 前缀与后缀匹配
         在 P[j] = * 处失配时，向右移r1；当然，会不会漏掉 P[k] = X 的对齐位置呢？不会，因为若要在 P[k] 处成功匹配
                                        所有字符串，则 P[k] 与 P[j] 之间必定含有子串 abc，那么 r1 距离的起点就应
                                        该在 P[k] 与 P[j] 之间
         在 P[i] = # 处失配时，向右移r2；</pre><pre>(2) 由ss计算gs：
    j，ss[j] = 4
[abcd        abcd]
ss[j]：即在P中与P后缀相同，且以P[j]为未字符的子串(或前缀)的长度</pre><pre>(2.1)若存在为前缀的good suffix，必有 ss[j]=j+1, ss[i]=i+1：
 0 i  j        k  h
[abcabc        abcabc]
              [abcabc        abcabc]
                 [abcabc        abcabc]
在[0,k)之间发生失配时，均可以右移gs[x] = Len(P)-ss[j] = Len(P)-(j+1)
在[k,h)之间发生失配时，均可以右移gs[x] = Len(P)-ss[i] = Len(P)-(i+1)
其中有：k = Len(P) - (j+1)
        h = Len(P) - (i+1)</pre><pre>(2.2)若存在为子中的good suffix，必有ss[j] &lt; j+1：
 0     j         i: 失配点
[    abc          abc]
            [abcd        abcd]
在i失配，则右移gs[i] = Len(P) - (j+1), i = Len(P) - ss[j] - 1
ss[j] = 0       : i = Len(P) - ss[j] - 1 = max-index
0 &lt; ss[j] &lt; j+1 : i = Len(P) - ss[j] - 1</pre><pre>(3) 示例：
 0  1  2  3  4  5  6  7  =&gt; index
 非 曰 静 也 善 故 静 也
 A  B  C  D  E  F  C  D
 0  0  0  2  0  0  0  8  =&gt; ss
 8  8  8  8  8  4  8  1  =&gt; gs</pre><pre> A  B  A  B  x  y  z  A  B  A  B
 0  2  0  4  0  0  0  0  2  0  11 =&gt; ss
 7  7  7  7  7  7  7  9  2 11  1  =&gt; gs</pre><pre></pre><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">P</td><td>Pattern，模式字符，即待匹配的字符 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd></dd></dl>
<dl class="retval"><dt>返回值</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6172d6a559c55ac355e43342164e8a06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6172d6a559c55ac355e43342164e8a06">&#9670;&nbsp;</a></span>build_next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int * dsa::build_next </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>P</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>建立next表 </p>
<pre></pre><pre>next[j+1] &lt;= next[j] + 1
当j=0时，因为next[0]=-1为假想的通配符，则必有P[0]=P[next[0]]=P[-1]，
因而 next[1] = next[0] + 1</pre><pre>而对于任何j都有：
next[j] + 1 &lt;= next[j-1] + 1 &lt;= ... &lt;= next[0] + 1
从而可以推出(因为每一次&lt;=都加了1，共加了j次)：
next[j] &lt; j</pre><pre>算法示意图：</pre><pre>             j
[  P[0,j)    # P[j,m)]
             -----
                \
                 这一段存在可能匹配成功的真前缀和真后缀
匹配：          /
             -----
            [# P[0,t)      P[j,m)]
             t，t从0开始，做为P[0,j)的真前缀的第一个字符，j为P[0,j)真后缀的第一个字符
             j和t每一次自增，即是P[0,j)匹配的真前缀的真后缀的长度加1
失配：
             t = next[t]，因为t&gt;next[t]，故最终可到t=next[0]=-1，则有P[j+1] = next[0]+1 = 0
  [  P[0,t)  *   P[j,m)]
   ----------
   这一段是已经匹配成功的真前缀</pre><pre>匹配实例演示：
                  j j+1
c  h  i  n  c  h  i  l  l  a
-1 0  0  0  0  1  2           -&gt; next[j]
      t = 2
因为 P[j] = P[t]，则 P[j+1] = t+1 = 2+1 = 3;</pre><pre>失配实例演示：
                     j j+1
c  h  i  n  c  h  i  l  l  a
-1 0  0  0  0  1  2  3        -&gt; next[j]
         t = 3
因为 l = P[j] != P[3] = n，则t = next[3] = 0，
接着 l = P[j] != P[0] = c，则t = next[0] =-1，
接着 t &lt; 0，故next[j+1] = t+1 = -1+1 = 0</pre><pre></pre><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">P</td><td>Pattern，模式字符，即待匹配的字符 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd></dd></dl>
<dl class="retval"><dt>返回值</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaaec7b26a216963749bba23d7f58b82e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaec7b26a216963749bba23d7f58b82e6">&#9670;&nbsp;</a></span>build_next_improved()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int * dsa::build_next_improved </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>P</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>建立next表改进版 </p>
<pre></pre><pre>改进版：
设P与T进行匹配，且匹配到了T[i]处</pre><pre>情况一：连接好向个字符相同
    j j+1
[0  0  0  0  0  0  1]
-1 -1                   -&gt; next[j]
 t t+1
若P[j] = P[t] 且 P[j+1] = P[t+1]，则next[j+1] = next[t+1] = -1；</pre><pre>同理一直推下去，可知前6个0的next均为-1；
这样，若T[i]与P[j+1]失配，可以让P直接从头开始比较，
P[j+1]前面的相同的0无需再比较（比较也肯定失配）。</pre><pre>情况二：普通情况
             j j+1
[a  b  c  *  a  b  #]
-1  0  0     0  1        -&gt; next[]
-1  0  0    -1  0        -&gt; next_improved[]
 t t+1</pre><pre>若P[j] = P[j] 且 P[j+1] = P[t+1]，则next[j+1] = next[t+1] = 0；</pre><pre>按原来算法，若T[i]与P[j+1]失配，
接着，应该让T[i]与 P[next[j+1]] = P[t+1] 比较</pre><pre>按照改进算法，若T[i]与P[j+1]失配，
接着，直接让T[i]与 P[next[j+1] = P[0] 比较，
因为既然T[i] != P[j+1]，也就有T[i] != P[t+1]，再比较T[i]与P[t+1]肯定也是失配
可以这样来理解：j+1指向处于P中的自相似的子串"ab"，第一个子串失配了，另一个子串也必然失配。</pre><pre></pre><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">P</td><td>Pattern，模式字符，即待匹配的字符 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd></dd></dl>
<dl class="retval"><dt>返回值</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7009fa633463e4403e3cad0478c6910a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7009fa633463e4403e3cad0478c6910a">&#9670;&nbsp;</a></span>match_bf1()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int dsa::match_bf1 </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>T</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>蛮力匹配(Brute-force-1) </p>
<pre></pre><pre>时间复杂度：
len(P) = m , len(T) = n
O(n+m) &lt;= BF &lt;= O(n*m)</pre><pre>示意图：
                           i
Text: ------ [           ] X -------------
Pattern:     [           ] Y [     ]
                           j
</pre><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">P</td><td>Pattern，模式字符，即待匹配的字符 </td></tr>
    <tr><td class="paramname">T</td><td>Text，文本字符 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd></dd></dl>
<dl class="retval"><dt>返回值</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga582dcdb5f9becbf92816d2461abaef4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga582dcdb5f9becbf92816d2461abaef4e">&#9670;&nbsp;</a></span>match_bf2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int dsa::match_bf2 </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>T</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>蛮力匹配(Brute-force-2) </p>
<pre></pre><pre>时间复杂度：
len(P) = m , len(T) = n
O(n+m) &lt;= BF &lt;= O(n*m)</pre><pre>示意图：
              i           i+j
Text: ------ [           ] X -------------
Pattern:     [           ] Y [     ]
                           j
</pre><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">P</td><td>Pattern，模式字符，即待匹配的字符 </td></tr>
    <tr><td class="paramname">T</td><td>Text，文本字符 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd></dd></dl>
<dl class="retval"><dt>返回值</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf6fa260ff01c5f9166d69b5fc81a5ab5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf6fa260ff01c5f9166d69b5fc81a5ab5">&#9670;&nbsp;</a></span>match_bm_bc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int dsa::match_bm_bc </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>T</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>BM匹配算法 </p>
<pre>
BM算法：首次失配的概率越小，性能优势越明显；适合大字符表。
时间复杂度：
len(P) = m , len(T) = n
O(n/m) &lt;= BC &lt;= O(n*m)
O(n/m) &lt;= BC+GS &lt;= O(n+m)</pre><pre>从右向左，对字符串进行比对。
              i           i+j
Text: ------ [           ] X [*****]----------
Pattern:     [           ] Y [*****]
                           j: 失配点
bc表：
     失配之处为“教训”，要想匹配成功，下一次比对的字符应当为失配字符。</pre><pre>gs表：
     失配之处为“经验”，与KMP类似，借助模式字符串的自相似性。</pre><pre></pre><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">P</td><td>Pattern，模式字符，即待匹配的字符 </td></tr>
    <tr><td class="paramname">T</td><td>Text，文本字符 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd></dd></dl>
<dl class="retval"><dt>返回值</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac169036d3ff06d936ae8e6c4fe2f98eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac169036d3ff06d936ae8e6c4fe2f98eb">&#9670;&nbsp;</a></span>match_bm_bcgs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int dsa::match_bm_bcgs </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>T</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>BM+GS匹配算法 </p>
<p>用gs表代替bc的情况3</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">P</td><td>Pattern，模式字符，即待匹配的字符 </td></tr>
    <tr><td class="paramname">T</td><td>Text，文本字符 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd></dd></dl>
<dl class="retval"><dt>返回值</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf3e734ffbeda146022f684dad29d29c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf3e734ffbeda146022f684dad29d29c7">&#9670;&nbsp;</a></span>match_kmp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int dsa::match_kmp </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>T</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>KMP匹配算法 </p>
<pre></pre><pre>KMP算法：匹配概率越高，优势越明显；适合小字符表。
时间复杂度：
len(P) = m , len(T) = n
KMP = O(n+m)</pre><pre>示例：
0  1  2  3  4  5  6  7  8  9  -&gt; 字符的下标j
c  h  i  n  c  h  i  l  l  a
-1 0  0  0  0  1  2  3  0  0  -&gt; next[j]</pre><pre>                            失配点
                          /
Text    :  c h i n c h i *
Pattern :  c h i n c h i l l a
next[j] :          c h i n c h i l l a
如果在 l 处失配，说明 l 前的 chi 是匹配的，
故pattern最开始的 chi 则不需要再次比较。</pre><pre>Next[j]的建立：
                                       i -&gt; 失配点下标
Text: ---------- [     ][  P[j-t,j)  ] x ----------
                 |       ------------|
                 |     P[0,j)的真后缀|
                 |                   |
                 [  P的前缀：P[0,j)  ]
                 |                   |
                 |                   | j -&gt; 失配点下标
Pattern:         [   P[0,t)   ][     ] y -----
                 |------------       |
                 |P[0,j)的真前缀     |
                 |                   |
                 |                   | t -&gt; 新的比较点
                 |  j-t  [   P[0,t)  ] z -------
                          -----------
                         P[0,j)的真前缀
     当P[j-t,j) 与 P[0,t)相等，则无需要再比较，直接从新的比较点t开始匹配</pre><pre>对任意失配点j，next[j]的值为：
next[j] = N(P,j) = { 0 &lt;= t &lt; j | P[0,t) == P[j-t, j) }
即：
     在P的前缀P[0,j)中，P[0,j)的真前缀P[0,t)和真后缀P[j-t,j)匹配的长度，就是next[j]；
     若有多个匹配的真前缀和真后缀，则取长度最长的（即使得移动距离j-t最小）；
     因为“大”长度的，肯定包含了“小”长度真前缀和真后缀。</pre><pre>可推出：
next[j+1] &lt;= next[j] + 1
当且仅当 P[j] == P[next[j]] 时取等号
理解如下：
             j+1
[   P[0,j+1) |   ]
            j|
[   P[0,j)  ||   ]
[    *******#?   ]       =&gt; P[j] = #, next[j] = 7, next[j] &lt; j （真后缀的长度比P[0,j)的长度小）
    [*******#?       ]   =&gt; P[7] = # = P[next[j]]，则有P[j] = P[next[j]]
     --------
    此段是 P[0,j) 的真前缀和真后缀，其长度，也即 * 的个数，就是next[j] = 7 (注意P[0,j)未包括j)；
    而next[j+1]相对于next[j]多了个 #，即P[0,j+1)的真前缀和真后缀匹配的长度加1</pre><pre></pre><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">P</td><td>Pattern，模式字符，即待匹配的字符 </td></tr>
    <tr><td class="paramname">T</td><td>Text，文本字符 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd></dd></dl>
<dl class="retval"><dt>返回值</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae20271e600a2cc9681f78fd4743b8acc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae20271e600a2cc9681f78fd4743b8acc">&#9670;&nbsp;</a></span>strlen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int dsa::strlen </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>获取字符串长度 </p>
<p>不包括'\0'</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>字符串，以'\0'结尾 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd></dd></dl>
<dl class="retval"><dt>返回值</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
制作者 &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
